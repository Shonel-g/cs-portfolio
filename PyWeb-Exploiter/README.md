# PyWeb-Exploiter
### Automated Web Security Testing Framework

**Status:** Active Development / Educational  
**Language:** Python 3

---

### üéØ Project Purpose
This project serves as a **Proof of Concept (PoC)** designed to bridge the gap between theoretical cybersecurity knowledge (Cisco certifications) and practical application. 

The primary goal is to demonstrate **"Custom Tooling"** capabilities: the ability to build tailored security assessment tools from scratch rather than relying solely on automated commercial scanners.

Additionally, the framework is engineered to be **lightweight and CLI-based**. This design choice ensures that complex security tests can be performed efficiently even on legacy hardware or resource-constrained environments where heavy GUI-based suites (like Burp Suite) might perform poorly.

### üõ† Architecture
The framework follows a **Modular and Object-Oriented (OOP)** approach:

*   **Core Engine:** Centralized HTTP session management (`requests.Session`) to handle cookies, persistence, and headers automatically.
*   **Modular Design:** Each attack vector (e.g., SQL Injection) is encapsulated within its own class in the `modules/` package, ensuring scalability and code maintainability.
*   **CLI Interface:** User-friendly command-line interface built with `argparse` for rapid, scriptable execution.

---

### üìú Development Log & Version History
This log tracks the evolution of the tool, highlighting technical obstacles encountered and the engineering solutions applied to resolve them.

#### **v1.2 - The "CSRF" Fix (Current Stable)**
*   **Issue Encountered:** During live fire testing against *PortSwigger Web Security Academy* labs, the SQL Injection module was consistently failing, despite the payloads being syntactically correct.
*   **Root Cause Analysis:** By analyzing the HTTP responses (Status 200 OK but failed login), I discovered the target application enforced a **CSRF (Cross-Site Request Forgery) Token**. The server required this dynamic hidden token to be present in the POST request; otherwise, it silently rejected the credentials.
*   **Engineering Solution:** 
    *   Integrated **BeautifulSoup4** for HTML parsing.
    *   Implemented a helper method `_get_csrf_token()` that performs a preliminary GET request, scrapes the dynamic token from the DOM, and automatically injects it into the subsequent attack payload.
*   **Result:** Successfully achieved authentication bypass on CSRF-protected forms.
<img width="1082" height="366" alt="Schermata 2025-11-19 alle 12 34 46 copia" src="https://github.com/user-attachments/assets/0f3c6183-0553-427d-82cd-0722538f7122" />

#### **v1.1 - Modular Refactoring**
*   **Change:** Transitioned from standalone "single-use" scripts to a unified Framework structure.
*   **Implementation:** Introduced `main.py` as the entry point with argument parsing (`--target`, `--attack`) and organized the codebase into a `modules/` package.
*   **Goal:** Clean code architecture and preparation for supporting multiple attack vectors in the future.

#### **v1.0 - Initial Prototype**
*   **Functionality:** Basic scripts to test SQL Injection (Blind & Login Bypass).
*   **Status:** Functional Proof of Concept, but lacked robust error handling and session persistence.

---

### üöÄ Tech Stack
*   **Python 3**
*   **Requests:** For low-level HTTP/1.1 interaction.
*   **BeautifulSoup4:** For HTML parsing and security token extraction.
*   **Argparse:** For CLI argument management.

### ‚ö†Ô∏è Disclaimer
*This tool is developed for educational purposes and authorized security testing only. Usage of this code for attacking targets without prior mutual consent is illegal.*
